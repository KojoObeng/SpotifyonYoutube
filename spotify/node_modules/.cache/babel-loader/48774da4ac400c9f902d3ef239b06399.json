{"ast":null,"code":"/*! yt-player. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nconst EventEmitter = require('events').EventEmitter;\n\nconst loadScript = require('load-script2');\n\nconst YOUTUBE_IFRAME_API_SRC = 'https://www.youtube.com/iframe_api';\nconst YOUTUBE_STATES = {\n  '-1': 'unstarted',\n  0: 'ended',\n  1: 'playing',\n  2: 'paused',\n  3: 'buffering',\n  5: 'cued'\n};\nconst YOUTUBE_ERROR = {\n  // The request contains an invalid parameter value. For example, this error\n  // occurs if you specify a videoId that does not have 11 characters, or if the\n  // videoId contains invalid characters, such as exclamation points or asterisks.\n  INVALID_PARAM: 2,\n  // The requested content cannot be played in an HTML5 player or another error\n  // related to the HTML5 player has occurred.\n  HTML5_ERROR: 5,\n  // The video requested was not found. This error occurs when a video has been\n  // removed (for any reason) or has been marked as private.\n  NOT_FOUND: 100,\n  // The owner of the requested video does not allow it to be played in embedded\n  // players.\n  UNPLAYABLE_1: 101,\n  // This error is the same as 101. It's just a 101 error in disguise!\n  UNPLAYABLE_2: 150\n};\nconst loadIframeAPICallbacks = [];\n/**\n * YouTube Player. Exposes a better API, with nicer events.\n * @param {HTMLElement|selector} element\n */\n\nclass YouTubePlayer extends EventEmitter {\n  constructor(element, opts) {\n    super();\n    const elem = typeof element === 'string' ? document.querySelector(element) : element;\n\n    if (elem.id) {\n      this._id = elem.id; // use existing element id\n    } else {\n      this._id = elem.id = 'ytplayer-' + Math.random().toString(16).slice(2, 8);\n    }\n\n    this._opts = Object.assign({\n      width: 640,\n      height: 360,\n      autoplay: false,\n      captions: undefined,\n      controls: true,\n      keyboard: true,\n      fullscreen: true,\n      annotations: true,\n      modestBranding: false,\n      related: true,\n      timeupdateFrequency: 1000,\n      playsInline: true,\n      start: 0\n    }, opts);\n    this.videoId = null;\n    this.destroyed = false;\n    this._api = null;\n    this._autoplay = false; // autoplay the first video?\n\n    this._player = null;\n    this._ready = false; // is player ready?\n\n    this._queue = [];\n    this._interval = null; // Setup listeners for 'timeupdate' events. The YouTube Player does not fire\n    // 'timeupdate' events, so they are simulated using a setInterval().\n\n    this._startInterval = this._startInterval.bind(this);\n    this._stopInterval = this._stopInterval.bind(this);\n    this.on('playing', this._startInterval);\n    this.on('unstarted', this._stopInterval);\n    this.on('ended', this._stopInterval);\n    this.on('paused', this._stopInterval);\n    this.on('buffering', this._stopInterval);\n\n    this._loadIframeAPI((err, api) => {\n      if (err) return this._destroy(new Error('YouTube Iframe API failed to load'));\n      this._api = api; // If load(videoId, [autoplay, [size]]) was called before Iframe API\n      // loaded, ensure it gets called again now\n\n      if (this.videoId) this.load(this.videoId, this._autoplay, this._start);\n    });\n  }\n\n  load(videoId, autoplay = false, start = 0) {\n    if (this.destroyed) return;\n    this.videoId = videoId;\n    this._autoplay = autoplay;\n    this._start = start; // If the Iframe API is not ready yet, do nothing. Once the Iframe API is\n    // ready, `load(this.videoId)` will be called.\n\n    if (!this._api) return; // If there is no player instance, create one.\n\n    if (!this._player) {\n      this._createPlayer(videoId);\n\n      return;\n    } // If the player instance is not ready yet, do nothing. Once the player\n    // instance is ready, `load(this.videoId)` will be called. This ensures that\n    // the last call to `load()` is the one that takes effect.\n\n\n    if (!this._ready) return; // If the player instance is ready, load the given `videoId`.\n\n    if (autoplay) {\n      this._player.loadVideoById(videoId, start);\n    } else {\n      this._player.cueVideoById(videoId, start);\n    }\n  }\n\n  play() {\n    if (this._ready) this._player.playVideo();else this._queueCommand('play');\n  }\n\n  pause() {\n    if (this._ready) this._player.pauseVideo();else this._queueCommand('pause');\n  }\n\n  stop() {\n    if (this._ready) this._player.stopVideo();else this._queueCommand('stop');\n  }\n\n  seek(seconds) {\n    if (this._ready) this._player.seekTo(seconds, true);else this._queueCommand('seek', seconds);\n  }\n\n  setVolume(volume) {\n    if (this._ready) this._player.setVolume(volume);else this._queueCommand('setVolume', volume);\n  }\n\n  getVolume() {\n    return this._ready && this._player.getVolume() || 0;\n  }\n\n  mute() {\n    if (this._ready) this._player.mute();else this._queueCommand('mute');\n  }\n\n  unMute() {\n    if (this._ready) this._player.unMute();else this._queueCommand('unMute');\n  }\n\n  isMuted() {\n    return this._ready && this._player.isMuted() || false;\n  }\n\n  setSize(width, height) {\n    if (this._ready) this._player.setSize(width, height);else this._queueCommand('setSize', width, height);\n  }\n\n  setPlaybackRate(rate) {\n    if (this._ready) this._player.setPlaybackRate(rate);else this._queueCommand('setPlaybackRate', rate);\n  }\n\n  setPlaybackQuality(suggestedQuality) {\n    if (this._ready) this._player.setPlaybackQuality(suggestedQuality);else this._queueCommand('setPlaybackQuality', suggestedQuality);\n  }\n\n  getPlaybackRate() {\n    return this._ready && this._player.getPlaybackRate() || 1;\n  }\n\n  getAvailablePlaybackRates() {\n    return this._ready && this._player.getAvailablePlaybackRates() || [1];\n  }\n\n  getDuration() {\n    return this._ready && this._player.getDuration() || 0;\n  }\n\n  getProgress() {\n    return this._ready && this._player.getVideoLoadedFraction() || 0;\n  }\n\n  getState() {\n    return this._ready && YOUTUBE_STATES[this._player.getPlayerState()] || 'unstarted';\n  }\n\n  getCurrentTime() {\n    return this._ready && this._player.getCurrentTime() || 0;\n  }\n\n  destroy() {\n    this._destroy();\n  }\n\n  _destroy(err) {\n    if (this.destroyed) return;\n    this.destroyed = true;\n\n    if (this._player) {\n      this._player.stopVideo && this._player.stopVideo();\n\n      this._player.destroy();\n    }\n\n    this.videoId = null;\n    this._id = null;\n    this._opts = null;\n    this._api = null;\n    this._player = null;\n    this._ready = false;\n    this._queue = null;\n\n    this._stopInterval();\n\n    this.removeListener('playing', this._startInterval);\n    this.removeListener('paused', this._stopInterval);\n    this.removeListener('buffering', this._stopInterval);\n    this.removeListener('unstarted', this._stopInterval);\n    this.removeListener('ended', this._stopInterval);\n    if (err) this.emit('error', err);\n  }\n\n  _queueCommand(command, ...args) {\n    if (this.destroyed) return;\n\n    this._queue.push([command, args]);\n  }\n\n  _flushQueue() {\n    while (this._queue.length) {\n      const command = this._queue.shift();\n\n      this[command[0]].apply(this, command[1]);\n    }\n  }\n\n  _loadIframeAPI(cb) {\n    // If API is loaded, there is nothing else to do\n    if (window.YT && typeof window.YT.Player === 'function') {\n      return cb(null, window.YT);\n    } // Otherwise, queue callback until API is loaded\n\n\n    loadIframeAPICallbacks.push(cb);\n    const scripts = Array.from(document.getElementsByTagName('script'));\n    const isLoading = scripts.some(script => script.src === YOUTUBE_IFRAME_API_SRC); // If API <script> tag is not present in the page, inject it. Ensures that\n    // if user includes a hardcoded <script> tag in HTML for performance, another\n    // one will not be added\n\n    if (!isLoading) {\n      loadScript(YOUTUBE_IFRAME_API_SRC).catch(err => {\n        while (loadIframeAPICallbacks.length) {\n          const loadCb = loadIframeAPICallbacks.shift();\n          loadCb(err);\n        }\n      });\n    }\n\n    const prevOnYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady;\n\n    window.onYouTubeIframeAPIReady = () => {\n      if (typeof prevOnYouTubeIframeAPIReady === 'function') {\n        prevOnYouTubeIframeAPIReady();\n      }\n\n      while (loadIframeAPICallbacks.length) {\n        const loadCb = loadIframeAPICallbacks.shift();\n        loadCb(null, window.YT);\n      }\n    };\n  }\n\n  _createPlayer(videoId) {\n    if (this.destroyed) return;\n    const opts = this._opts;\n    this._player = new this._api.Player(this._id, {\n      width: opts.width,\n      height: opts.height,\n      videoId: videoId,\n      // (Not part of documented API) This parameter controls the hostname that\n      // videos are loaded from. Set to `'https://www.youtube-nocookie.com'`\n      // for enhanced privacy.\n      host: opts.host,\n      playerVars: {\n        // This parameter specifies whether the initial video will automatically\n        // start to play when the player loads. Supported values are 0 or 1. The\n        // default value is 0.\n        autoplay: opts.autoplay ? 1 : 0,\n        // Setting the parameter's value to 1 causes closed captions to be shown\n        // by default, even if the user has turned captions off. The default\n        // behavior is based on user preference.\n        cc_load_policy: opts.captions != null ? opts.captions !== false ? 1 : 0 : undefined,\n        // default to not setting this option\n        // Sets the player's interface language. The parameter value is an ISO\n        // 639-1 two-letter language code or a fully specified locale. For\n        // example, fr and fr-ca are both valid values. Other language input\n        // codes, such as IETF language tags (BCP 47) might also be handled\n        // properly.\n        hl: opts.captions != null && opts.captions !== false ? opts.captions : undefined,\n        // default to not setting this option\n        // This parameter specifies the default language that the player will\n        // use to display captions. Set the parameter's value to an ISO 639-1\n        // two-letter language code.\n        cc_lang_pref: opts.captions != null && opts.captions !== false ? opts.captions : undefined,\n        // default to not setting this option\n        // This parameter indicates whether the video player controls are\n        // displayed. For IFrame embeds that load a Flash player, it also defines\n        // when the controls display in the player as well as when the player\n        // will load. Supported values are:\n        //   - controls=0 – Player controls do not display in the player. For\n        //                  IFrame embeds, the Flash player loads immediately.\n        //   - controls=1 – (default) Player controls display in the player. For\n        //                  IFrame embeds, the controls display immediately and\n        //                  the Flash player also loads immediately.\n        //   - controls=2 – Player controls display in the player. For IFrame\n        //                  embeds, the controls display and the Flash player\n        //                  loads after the user initiates the video playback.\n        controls: opts.controls ? 2 : 0,\n        // Setting the parameter's value to 1 causes the player to not respond to\n        // keyboard controls. The default value is 0, which means that keyboard\n        // controls are enabled.\n        disablekb: opts.keyboard ? 0 : 1,\n        // Setting the parameter's value to 1 enables the player to be\n        // controlled via IFrame or JavaScript Player API calls. The default\n        // value is 0, which means that the player cannot be controlled using\n        // those APIs.\n        enablejsapi: 1,\n        // Setting this parameter to 0 prevents the fullscreen button from\n        // displaying in the player. The default value is 1, which causes the\n        // fullscreen button to display.\n        fs: opts.fullscreen ? 1 : 0,\n        // Setting the parameter's value to 1 causes video annotations to be\n        // shown by default, whereas setting to 3 causes video annotations to not\n        // be shown by default. The default value is 1.\n        iv_load_policy: opts.annotations ? 1 : 3,\n        // This parameter lets you use a YouTube player that does not show a\n        // YouTube logo. Set the parameter value to 1 to prevent the YouTube logo\n        // from displaying in the control bar. Note that a small YouTube text\n        // label will still display in the upper-right corner of a paused video\n        // when the user's mouse pointer hovers over the player.\n        modestbranding: opts.modestBranding ? 1 : 0,\n        // This parameter provides an extra security measure for the IFrame API\n        // and is only supported for IFrame embeds. If you are using the IFrame\n        // API, which means you are setting the enablejsapi parameter value to 1,\n        // you should always specify your domain as the origin parameter value.\n        origin: window.location.origin,\n        // This parameter controls whether videos play inline or fullscreen in an\n        // HTML5 player on iOS. Valid values are:\n        //   - 0: This value causes fullscreen playback. This is currently the\n        //        default value, though the default is subject to change.\n        //   - 1: This value causes inline playback for UIWebViews created with\n        //        the allowsInlineMediaPlayback property set to TRUE.\n        playsinline: opts.playsInline ? 1 : 0,\n        // This parameter indicates whether the player should show related\n        // videos from the same channel (0) or from any channel (1) when\n        // playback of the video ends. The default value is 1.\n        rel: opts.related ? 1 : 0,\n        // (Not part of documented API) Allow html elements with higher z-index\n        // to be shown on top of the YouTube player.\n        wmode: 'opaque',\n        // This parameter causes the player to begin playing the video at the given number\n        // of seconds from the start of the video. The parameter value is a positive integer.\n        // Note that similar to the seek function, the player will look for the closest\n        // keyframe to the time you specify. This means that sometimes the play head may seek\n        // to just before the requested time, usually no more than around two seconds.\n        start: opts.start\n      },\n      events: {\n        onReady: () => this._onReady(videoId),\n        onStateChange: data => this._onStateChange(data),\n        onPlaybackQualityChange: data => this._onPlaybackQualityChange(data),\n        onPlaybackRateChange: data => this._onPlaybackRateChange(data),\n        onError: data => this._onError(data)\n      }\n    });\n  }\n  /**\n   * This event fires when the player has finished loading and is ready to begin\n   * receiving API calls.\n   */\n\n\n  _onReady(videoId) {\n    if (this.destroyed) return;\n    this._ready = true; // Once the player is ready, always call `load(videoId, [autoplay, [size]])`\n    // to handle these possible cases:\n    //\n    //   1. `load(videoId, true)` was called before the player was ready. Ensure that\n    //      the selected video starts to play.\n    //\n    //   2. `load(videoId, false)` was called before the player was ready. Now the\n    //      player is ready and there's nothing to do.\n    //\n    //   3. `load(videoId, [autoplay])` was called multiple times before the player\n    //      was ready. Therefore, the player was initialized with the wrong videoId,\n    //      so load the latest videoId and potentially autoplay it.\n\n    this.load(this.videoId, this._autoplay, this._start);\n\n    this._flushQueue();\n  }\n  /**\n   * Called when the player's state changes. We emit friendly events so the user\n   * doesn't need to use YouTube's YT.PlayerState.* event constants.\n   */\n\n\n  _onStateChange(data) {\n    if (this.destroyed) return;\n    const state = YOUTUBE_STATES[data.data];\n\n    if (state) {\n      // Send a 'timeupdate' anytime the state changes. When the video halts for any\n      // reason ('paused', 'buffering', or 'ended') no further 'timeupdate' events\n      // should fire until the video unhalts.\n      if (['paused', 'buffering', 'ended'].includes(state)) this._onTimeupdate();\n      this.emit(state); // When the video changes ('unstarted' or 'cued') or starts ('playing') then a\n      // 'timeupdate' should follow afterwards (never before!) to reset the time.\n\n      if (['unstarted', 'playing', 'cued'].includes(state)) this._onTimeupdate();\n    } else {\n      throw new Error('Unrecognized state change: ' + data);\n    }\n  }\n  /**\n   * This event fires whenever the video playback quality changes. Possible\n   * values are: 'small', 'medium', 'large', 'hd720', 'hd1080', 'highres'.\n   */\n\n\n  _onPlaybackQualityChange(data) {\n    if (this.destroyed) return;\n    this.emit('playbackQualityChange', data.data);\n  }\n  /**\n   * This event fires whenever the video playback rate changes.\n   */\n\n\n  _onPlaybackRateChange(data) {\n    if (this.destroyed) return;\n    this.emit('playbackRateChange', data.data);\n  }\n  /**\n   * This event fires if an error occurs in the player.\n   */\n\n\n  _onError(data) {\n    if (this.destroyed) return;\n    const code = data.data; // The HTML5_ERROR error occurs when the YouTube player needs to switch from\n    // HTML5 to Flash to show an ad. Ignore it.\n\n    if (code === YOUTUBE_ERROR.HTML5_ERROR) return; // The remaining error types occur when the YouTube player cannot play the\n    // given video. This is not a fatal error. Report it as unplayable so the user\n    // has an opportunity to play another video.\n\n    if (code === YOUTUBE_ERROR.UNPLAYABLE_1 || code === YOUTUBE_ERROR.UNPLAYABLE_2 || code === YOUTUBE_ERROR.NOT_FOUND || code === YOUTUBE_ERROR.INVALID_PARAM) {\n      return this.emit('unplayable', this.videoId);\n    } // Unexpected error, does not match any known type\n\n\n    this._destroy(new Error('YouTube Player Error. Unknown error code: ' + code));\n  }\n  /**\n   * This event fires when the time indicated by the `getCurrentTime()` method\n   * has been updated.\n   */\n\n\n  _onTimeupdate() {\n    this.emit('timeupdate', this.getCurrentTime());\n  }\n\n  _startInterval() {\n    this._interval = setInterval(() => this._onTimeupdate(), this._opts.timeupdateFrequency);\n  }\n\n  _stopInterval() {\n    clearInterval(this._interval);\n    this._interval = null;\n  }\n\n}\n\nmodule.exports = YouTubePlayer;","map":{"version":3,"sources":["C:/Users/Kwadw/OneDrive/Documents/Grind/Projects/React Projects/Spotify/node_modules/yt-player/index.js"],"names":["EventEmitter","require","loadScript","YOUTUBE_IFRAME_API_SRC","YOUTUBE_STATES","YOUTUBE_ERROR","INVALID_PARAM","HTML5_ERROR","NOT_FOUND","UNPLAYABLE_1","UNPLAYABLE_2","loadIframeAPICallbacks","YouTubePlayer","constructor","element","opts","elem","document","querySelector","id","_id","Math","random","toString","slice","_opts","Object","assign","width","height","autoplay","captions","undefined","controls","keyboard","fullscreen","annotations","modestBranding","related","timeupdateFrequency","playsInline","start","videoId","destroyed","_api","_autoplay","_player","_ready","_queue","_interval","_startInterval","bind","_stopInterval","on","_loadIframeAPI","err","api","_destroy","Error","load","_start","_createPlayer","loadVideoById","cueVideoById","play","playVideo","_queueCommand","pause","pauseVideo","stop","stopVideo","seek","seconds","seekTo","setVolume","volume","getVolume","mute","unMute","isMuted","setSize","setPlaybackRate","rate","setPlaybackQuality","suggestedQuality","getPlaybackRate","getAvailablePlaybackRates","getDuration","getProgress","getVideoLoadedFraction","getState","getPlayerState","getCurrentTime","destroy","removeListener","emit","command","args","push","_flushQueue","length","shift","apply","cb","window","YT","Player","scripts","Array","from","getElementsByTagName","isLoading","some","script","src","catch","loadCb","prevOnYouTubeIframeAPIReady","onYouTubeIframeAPIReady","host","playerVars","cc_load_policy","hl","cc_lang_pref","disablekb","enablejsapi","fs","iv_load_policy","modestbranding","origin","location","playsinline","rel","wmode","events","onReady","_onReady","onStateChange","data","_onStateChange","onPlaybackQualityChange","_onPlaybackQualityChange","onPlaybackRateChange","_onPlaybackRateChange","onError","_onError","state","includes","_onTimeupdate","code","setInterval","clearInterval","module","exports"],"mappings":"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","sourcesContent":["/*! yt-player. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nconst EventEmitter = require('events').EventEmitter\nconst loadScript = require('load-script2')\n\nconst YOUTUBE_IFRAME_API_SRC = 'https://www.youtube.com/iframe_api'\n\nconst YOUTUBE_STATES = {\n  '-1': 'unstarted',\n  0: 'ended',\n  1: 'playing',\n  2: 'paused',\n  3: 'buffering',\n  5: 'cued'\n}\n\nconst YOUTUBE_ERROR = {\n  // The request contains an invalid parameter value. For example, this error\n  // occurs if you specify a videoId that does not have 11 characters, or if the\n  // videoId contains invalid characters, such as exclamation points or asterisks.\n  INVALID_PARAM: 2,\n\n  // The requested content cannot be played in an HTML5 player or another error\n  // related to the HTML5 player has occurred.\n  HTML5_ERROR: 5,\n\n  // The video requested was not found. This error occurs when a video has been\n  // removed (for any reason) or has been marked as private.\n  NOT_FOUND: 100,\n\n  // The owner of the requested video does not allow it to be played in embedded\n  // players.\n  UNPLAYABLE_1: 101,\n\n  // This error is the same as 101. It's just a 101 error in disguise!\n  UNPLAYABLE_2: 150\n}\n\nconst loadIframeAPICallbacks = []\n\n/**\n * YouTube Player. Exposes a better API, with nicer events.\n * @param {HTMLElement|selector} element\n */\nclass YouTubePlayer extends EventEmitter {\n  constructor (element, opts) {\n    super()\n\n    const elem = typeof element === 'string'\n      ? document.querySelector(element)\n      : element\n\n    if (elem.id) {\n      this._id = elem.id // use existing element id\n    } else {\n      this._id = elem.id = 'ytplayer-' + Math.random().toString(16).slice(2, 8)\n    }\n\n    this._opts = Object.assign({\n      width: 640,\n      height: 360,\n      autoplay: false,\n      captions: undefined,\n      controls: true,\n      keyboard: true,\n      fullscreen: true,\n      annotations: true,\n      modestBranding: false,\n      related: true,\n      timeupdateFrequency: 1000,\n      playsInline: true,\n      start: 0\n    }, opts)\n\n    this.videoId = null\n    this.destroyed = false\n\n    this._api = null\n    this._autoplay = false // autoplay the first video?\n    this._player = null\n    this._ready = false // is player ready?\n    this._queue = []\n\n    this._interval = null\n\n    // Setup listeners for 'timeupdate' events. The YouTube Player does not fire\n    // 'timeupdate' events, so they are simulated using a setInterval().\n    this._startInterval = this._startInterval.bind(this)\n    this._stopInterval = this._stopInterval.bind(this)\n\n    this.on('playing', this._startInterval)\n    this.on('unstarted', this._stopInterval)\n    this.on('ended', this._stopInterval)\n    this.on('paused', this._stopInterval)\n    this.on('buffering', this._stopInterval)\n\n    this._loadIframeAPI((err, api) => {\n      if (err) return this._destroy(new Error('YouTube Iframe API failed to load'))\n      this._api = api\n\n      // If load(videoId, [autoplay, [size]]) was called before Iframe API\n      // loaded, ensure it gets called again now\n      if (this.videoId) this.load(this.videoId, this._autoplay, this._start)\n    })\n  }\n\n  load (videoId, autoplay = false, start = 0) {\n    if (this.destroyed) return\n\n    this.videoId = videoId\n    this._autoplay = autoplay\n    this._start = start\n\n    // If the Iframe API is not ready yet, do nothing. Once the Iframe API is\n    // ready, `load(this.videoId)` will be called.\n    if (!this._api) return\n\n    // If there is no player instance, create one.\n    if (!this._player) {\n      this._createPlayer(videoId)\n      return\n    }\n\n    // If the player instance is not ready yet, do nothing. Once the player\n    // instance is ready, `load(this.videoId)` will be called. This ensures that\n    // the last call to `load()` is the one that takes effect.\n    if (!this._ready) return\n\n    // If the player instance is ready, load the given `videoId`.\n    if (autoplay) {\n      this._player.loadVideoById(videoId, start)\n    } else {\n      this._player.cueVideoById(videoId, start)\n    }\n  }\n\n  play () {\n    if (this._ready) this._player.playVideo()\n    else this._queueCommand('play')\n  }\n\n  pause () {\n    if (this._ready) this._player.pauseVideo()\n    else this._queueCommand('pause')\n  }\n\n  stop () {\n    if (this._ready) this._player.stopVideo()\n    else this._queueCommand('stop')\n  }\n\n  seek (seconds) {\n    if (this._ready) this._player.seekTo(seconds, true)\n    else this._queueCommand('seek', seconds)\n  }\n\n  setVolume (volume) {\n    if (this._ready) this._player.setVolume(volume)\n    else this._queueCommand('setVolume', volume)\n  }\n\n  getVolume () {\n    return (this._ready && this._player.getVolume()) || 0\n  }\n\n  mute () {\n    if (this._ready) this._player.mute()\n    else this._queueCommand('mute')\n  }\n\n  unMute () {\n    if (this._ready) this._player.unMute()\n    else this._queueCommand('unMute')\n  }\n\n  isMuted () {\n    return (this._ready && this._player.isMuted()) || false\n  }\n\n  setSize (width, height) {\n    if (this._ready) this._player.setSize(width, height)\n    else this._queueCommand('setSize', width, height)\n  }\n\n  setPlaybackRate (rate) {\n    if (this._ready) this._player.setPlaybackRate(rate)\n    else this._queueCommand('setPlaybackRate', rate)\n  }\n\n  setPlaybackQuality (suggestedQuality) {\n    if (this._ready) this._player.setPlaybackQuality(suggestedQuality)\n    else this._queueCommand('setPlaybackQuality', suggestedQuality)\n  }\n\n  getPlaybackRate () {\n    return (this._ready && this._player.getPlaybackRate()) || 1\n  }\n\n  getAvailablePlaybackRates () {\n    return (this._ready && this._player.getAvailablePlaybackRates()) || [1]\n  }\n\n  getDuration () {\n    return (this._ready && this._player.getDuration()) || 0\n  }\n\n  getProgress () {\n    return (this._ready && this._player.getVideoLoadedFraction()) || 0\n  }\n\n  getState () {\n    return (this._ready && YOUTUBE_STATES[this._player.getPlayerState()]) || 'unstarted'\n  }\n\n  getCurrentTime () {\n    return (this._ready && this._player.getCurrentTime()) || 0\n  }\n\n  destroy () {\n    this._destroy()\n  }\n\n  _destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n\n    if (this._player) {\n      this._player.stopVideo && this._player.stopVideo()\n      this._player.destroy()\n    }\n\n    this.videoId = null\n\n    this._id = null\n    this._opts = null\n    this._api = null\n    this._player = null\n    this._ready = false\n    this._queue = null\n\n    this._stopInterval()\n\n    this.removeListener('playing', this._startInterval)\n    this.removeListener('paused', this._stopInterval)\n    this.removeListener('buffering', this._stopInterval)\n    this.removeListener('unstarted', this._stopInterval)\n    this.removeListener('ended', this._stopInterval)\n\n    if (err) this.emit('error', err)\n  }\n\n  _queueCommand (command, ...args) {\n    if (this.destroyed) return\n    this._queue.push([command, args])\n  }\n\n  _flushQueue () {\n    while (this._queue.length) {\n      const command = this._queue.shift()\n      this[command[0]].apply(this, command[1])\n    }\n  }\n\n  _loadIframeAPI (cb) {\n    // If API is loaded, there is nothing else to do\n    if (window.YT && typeof window.YT.Player === 'function') {\n      return cb(null, window.YT)\n    }\n\n    // Otherwise, queue callback until API is loaded\n    loadIframeAPICallbacks.push(cb)\n\n    const scripts = Array.from(document.getElementsByTagName('script'))\n    const isLoading = scripts.some(script => script.src === YOUTUBE_IFRAME_API_SRC)\n\n    // If API <script> tag is not present in the page, inject it. Ensures that\n    // if user includes a hardcoded <script> tag in HTML for performance, another\n    // one will not be added\n    if (!isLoading) {\n      loadScript(YOUTUBE_IFRAME_API_SRC).catch(err => {\n        while (loadIframeAPICallbacks.length) {\n          const loadCb = loadIframeAPICallbacks.shift()\n          loadCb(err)\n        }\n      })\n    }\n\n    const prevOnYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady\n    window.onYouTubeIframeAPIReady = () => {\n      if (typeof prevOnYouTubeIframeAPIReady === 'function') {\n        prevOnYouTubeIframeAPIReady()\n      }\n      while (loadIframeAPICallbacks.length) {\n        const loadCb = loadIframeAPICallbacks.shift()\n        loadCb(null, window.YT)\n      }\n    }\n  }\n\n  _createPlayer (videoId) {\n    if (this.destroyed) return\n\n    const opts = this._opts\n\n    this._player = new this._api.Player(this._id, {\n      width: opts.width,\n      height: opts.height,\n      videoId: videoId,\n\n      // (Not part of documented API) This parameter controls the hostname that\n      // videos are loaded from. Set to `'https://www.youtube-nocookie.com'`\n      // for enhanced privacy.\n      host: opts.host,\n\n      playerVars: {\n        // This parameter specifies whether the initial video will automatically\n        // start to play when the player loads. Supported values are 0 or 1. The\n        // default value is 0.\n        autoplay: opts.autoplay ? 1 : 0,\n\n        // Setting the parameter's value to 1 causes closed captions to be shown\n        // by default, even if the user has turned captions off. The default\n        // behavior is based on user preference.\n        cc_load_policy: opts.captions != null\n          ? opts.captions !== false ? 1 : 0\n          : undefined, // default to not setting this option\n\n        // Sets the player's interface language. The parameter value is an ISO\n        // 639-1 two-letter language code or a fully specified locale. For\n        // example, fr and fr-ca are both valid values. Other language input\n        // codes, such as IETF language tags (BCP 47) might also be handled\n        // properly.\n        hl: (opts.captions != null && opts.captions !== false)\n          ? opts.captions\n          : undefined, // default to not setting this option\n\n        // This parameter specifies the default language that the player will\n        // use to display captions. Set the parameter's value to an ISO 639-1\n        // two-letter language code.\n        cc_lang_pref: (opts.captions != null && opts.captions !== false)\n          ? opts.captions\n          : undefined, // default to not setting this option\n\n        // This parameter indicates whether the video player controls are\n        // displayed. For IFrame embeds that load a Flash player, it also defines\n        // when the controls display in the player as well as when the player\n        // will load. Supported values are:\n        //   - controls=0 – Player controls do not display in the player. For\n        //                  IFrame embeds, the Flash player loads immediately.\n        //   - controls=1 – (default) Player controls display in the player. For\n        //                  IFrame embeds, the controls display immediately and\n        //                  the Flash player also loads immediately.\n        //   - controls=2 – Player controls display in the player. For IFrame\n        //                  embeds, the controls display and the Flash player\n        //                  loads after the user initiates the video playback.\n        controls: opts.controls ? 2 : 0,\n\n        // Setting the parameter's value to 1 causes the player to not respond to\n        // keyboard controls. The default value is 0, which means that keyboard\n        // controls are enabled.\n        disablekb: opts.keyboard ? 0 : 1,\n\n        // Setting the parameter's value to 1 enables the player to be\n        // controlled via IFrame or JavaScript Player API calls. The default\n        // value is 0, which means that the player cannot be controlled using\n        // those APIs.\n        enablejsapi: 1,\n\n        // Setting this parameter to 0 prevents the fullscreen button from\n        // displaying in the player. The default value is 1, which causes the\n        // fullscreen button to display.\n        fs: opts.fullscreen ? 1 : 0,\n\n        // Setting the parameter's value to 1 causes video annotations to be\n        // shown by default, whereas setting to 3 causes video annotations to not\n        // be shown by default. The default value is 1.\n        iv_load_policy: opts.annotations ? 1 : 3,\n\n        // This parameter lets you use a YouTube player that does not show a\n        // YouTube logo. Set the parameter value to 1 to prevent the YouTube logo\n        // from displaying in the control bar. Note that a small YouTube text\n        // label will still display in the upper-right corner of a paused video\n        // when the user's mouse pointer hovers over the player.\n        modestbranding: opts.modestBranding ? 1 : 0,\n\n        // This parameter provides an extra security measure for the IFrame API\n        // and is only supported for IFrame embeds. If you are using the IFrame\n        // API, which means you are setting the enablejsapi parameter value to 1,\n        // you should always specify your domain as the origin parameter value.\n        origin: window.location.origin,\n\n        // This parameter controls whether videos play inline or fullscreen in an\n        // HTML5 player on iOS. Valid values are:\n        //   - 0: This value causes fullscreen playback. This is currently the\n        //        default value, though the default is subject to change.\n        //   - 1: This value causes inline playback for UIWebViews created with\n        //        the allowsInlineMediaPlayback property set to TRUE.\n        playsinline: opts.playsInline ? 1 : 0,\n\n        // This parameter indicates whether the player should show related\n        // videos from the same channel (0) or from any channel (1) when\n        // playback of the video ends. The default value is 1.\n        rel: opts.related ? 1 : 0,\n\n        // (Not part of documented API) Allow html elements with higher z-index\n        // to be shown on top of the YouTube player.\n        wmode: 'opaque',\n\n        // This parameter causes the player to begin playing the video at the given number\n        // of seconds from the start of the video. The parameter value is a positive integer.\n        // Note that similar to the seek function, the player will look for the closest\n        // keyframe to the time you specify. This means that sometimes the play head may seek\n        // to just before the requested time, usually no more than around two seconds.\n        start: opts.start\n      },\n      events: {\n        onReady: () => this._onReady(videoId),\n        onStateChange: (data) => this._onStateChange(data),\n        onPlaybackQualityChange: (data) => this._onPlaybackQualityChange(data),\n        onPlaybackRateChange: (data) => this._onPlaybackRateChange(data),\n        onError: (data) => this._onError(data)\n      }\n    })\n  }\n\n  /**\n   * This event fires when the player has finished loading and is ready to begin\n   * receiving API calls.\n   */\n  _onReady (videoId) {\n    if (this.destroyed) return\n\n    this._ready = true\n\n    // Once the player is ready, always call `load(videoId, [autoplay, [size]])`\n    // to handle these possible cases:\n    //\n    //   1. `load(videoId, true)` was called before the player was ready. Ensure that\n    //      the selected video starts to play.\n    //\n    //   2. `load(videoId, false)` was called before the player was ready. Now the\n    //      player is ready and there's nothing to do.\n    //\n    //   3. `load(videoId, [autoplay])` was called multiple times before the player\n    //      was ready. Therefore, the player was initialized with the wrong videoId,\n    //      so load the latest videoId and potentially autoplay it.\n    this.load(this.videoId, this._autoplay, this._start)\n\n    this._flushQueue()\n  }\n\n  /**\n   * Called when the player's state changes. We emit friendly events so the user\n   * doesn't need to use YouTube's YT.PlayerState.* event constants.\n   */\n  _onStateChange (data) {\n    if (this.destroyed) return\n\n    const state = YOUTUBE_STATES[data.data]\n\n    if (state) {\n      // Send a 'timeupdate' anytime the state changes. When the video halts for any\n      // reason ('paused', 'buffering', or 'ended') no further 'timeupdate' events\n      // should fire until the video unhalts.\n      if (['paused', 'buffering', 'ended'].includes(state)) this._onTimeupdate()\n\n      this.emit(state)\n\n      // When the video changes ('unstarted' or 'cued') or starts ('playing') then a\n      // 'timeupdate' should follow afterwards (never before!) to reset the time.\n      if (['unstarted', 'playing', 'cued'].includes(state)) this._onTimeupdate()\n    } else {\n      throw new Error('Unrecognized state change: ' + data)\n    }\n  }\n\n  /**\n   * This event fires whenever the video playback quality changes. Possible\n   * values are: 'small', 'medium', 'large', 'hd720', 'hd1080', 'highres'.\n   */\n  _onPlaybackQualityChange (data) {\n    if (this.destroyed) return\n    this.emit('playbackQualityChange', data.data)\n  }\n\n  /**\n   * This event fires whenever the video playback rate changes.\n   */\n  _onPlaybackRateChange (data) {\n    if (this.destroyed) return\n    this.emit('playbackRateChange', data.data)\n  }\n\n  /**\n   * This event fires if an error occurs in the player.\n   */\n  _onError (data) {\n    if (this.destroyed) return\n\n    const code = data.data\n\n    // The HTML5_ERROR error occurs when the YouTube player needs to switch from\n    // HTML5 to Flash to show an ad. Ignore it.\n    if (code === YOUTUBE_ERROR.HTML5_ERROR) return\n\n    // The remaining error types occur when the YouTube player cannot play the\n    // given video. This is not a fatal error. Report it as unplayable so the user\n    // has an opportunity to play another video.\n    if (code === YOUTUBE_ERROR.UNPLAYABLE_1 ||\n        code === YOUTUBE_ERROR.UNPLAYABLE_2 ||\n        code === YOUTUBE_ERROR.NOT_FOUND ||\n        code === YOUTUBE_ERROR.INVALID_PARAM) {\n      return this.emit('unplayable', this.videoId)\n    }\n\n    // Unexpected error, does not match any known type\n    this._destroy(new Error('YouTube Player Error. Unknown error code: ' + code))\n  }\n\n  /**\n   * This event fires when the time indicated by the `getCurrentTime()` method\n   * has been updated.\n   */\n  _onTimeupdate () {\n    this.emit('timeupdate', this.getCurrentTime())\n  }\n\n  _startInterval () {\n    this._interval = setInterval(() => this._onTimeupdate(), this._opts.timeupdateFrequency)\n  }\n\n  _stopInterval () {\n    clearInterval(this._interval)\n    this._interval = null\n  }\n}\n\nmodule.exports = YouTubePlayer\n"]},"metadata":{},"sourceType":"script"}